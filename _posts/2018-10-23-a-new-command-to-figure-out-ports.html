---
layout: single
title: A new command to figure out ports
date: '2018-10-23T10:21:00.001-07:00'
tags: 
modified_time: '2018-10-23T10:21:24.299-07:00'
blogger_id: tag:blogger.com,1999:blog-17927613.post-3519316890016321392
blogger_orig_url: https://gunfus.blogspot.com/2018/10/a-new-command-to-figure-out-ports.html
---

Recently in a project as we were doing the setup of the system, our hosting provider made a typo in one of the MANY ports that our solution uses and it cause a lot of confussion.<br /><br />When creating the VIP (Virtual IPs) and ports mapping and the ports got flipped. Our hosting provider gave us a document saying this are your servers:<br /><br />| IP | server service |<br />| -- | -- |<br />| 10.2.3.120 | VIP for live |<br />| 10.2.3.121 | VIP for&nbsp; auth&nbsp; |<br />| 192.168.1.140 | IP for live |<br />| 192.168.1.141 | IP for&nbsp; auth&nbsp; |<br /><br />But we found out it was reversed, `.120` was auth and `.121` was live.<br /><br />So after a lot arguing and a lot of hours of explaining what happened, how to test, and reporting to people.<br /><br />I had the need to find a way to bring down the server and effectively test&nbsp; that we are hitting a particular server in a specific port, not through the ports that are used by the server and services because sometimes they may not necessarily tell me if I am hitting auth. My options:<br />- Check the access log in the web server<br />- Create different data in auth and live (a user or a product that exists in auth but not in live)<br />- Enable accesslog trace in the app server<br /><br />Find a way to test without the app server layer?<br /><br />Solution:&nbsp; <br /><br />From Auth:<br />1) logon to auth at 192.168.1.141<br />2) `nc -l 5001`<br /><br />From a client try:<br />3) http://10.2.3.120:5000<br /><br />4) in auth, check the output of the `nc` command